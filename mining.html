<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Mining Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --primary: #f7931a;
            --primary-dark: #e17c0e;
            --secondary: #4d4d4d;
            --dark: #1a1a1a;
            --light: #f8f8f8;
            --danger: #d9534f;
            --success: #5cb85c;
            --warning: #f0ad4e;
            --card-bg: #2d2d2d;
            --card-border: #3d3d3d;
            --text: #e0e0e0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--card-border);
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background-color: var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            color: var(--dark);
            animation: pulse 2s infinite;
        }

        .logo-text {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }

        .network-status {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: var(--card-bg);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--success);
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .network-status {
                align-self: flex-start;
            }
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--card-border);
            margin-bottom: 20px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--card-border);
        }

        .card-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: var(--dark);
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--secondary);
            color: var(--light);
        }

        .btn-secondary:hover {
            background-color: #3a3a3a;
        }

        .btn-danger {
            background-color: var(--danger);
            color: var(--light);
        }

        .btn-danger:hover {
            background-color: #c9302c;
        }

        .btn-success {
            background-color: var(--success);
            color: var(--light);
        }

        .btn-success:hover {
            background-color: #449d44;
        }

        .btn-warning {
            background-color: var(--warning);
            color: var(--dark);
        }

        .btn-warning:hover {
            background-color: #ec971f;
        }

        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mining-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mining-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
        }

        .mining-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: var(--warning);
        }

        .mining-indicator.active {
            background-color: var(--success);
            animation: pulse 1s infinite;
        }

        .mining-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-card {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--light);
            opacity: 0.7;
        }

        .blockchain-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 600px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--card-bg);
        }

        .blockchain-section::-webkit-scrollbar {
            width: 8px;
        }

        .blockchain-section::-webkit-scrollbar-track {
            background: var(--card-bg);
        }

        .blockchain-section::-webkit-scrollbar-thumb {
            background-color: var(--primary);
            border-radius: 20px;
        }

        .block {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
            margin-bottom: 10px;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .block.new-block {
            animation: fadeIn 0.5s ease-out;
        }

        .block-header {
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .block-header:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .block-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 15px;
        }

        .block-details.active {
            max-height: 1000px;
            padding: 15px;
            border-top: 1px solid var(--card-border);
        }

        .block-details p {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--card-border);
            margin-bottom: 20px;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .tabs::-webkit-scrollbar {
            display: none;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }

        .tab.active {
            opacity: 1;
            border-bottom: 2px solid var(--primary);
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        .network-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (max-width: 480px) {
            .network-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 90%;
        }

        .toast {
            background-color: var(--card-bg);
            color: var(--light);
            padding: 15px 20px;
            border-radius: 5px;
            margin-bottom: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateX(120%);
            animation: slideInRight 0.3s forwards;
            max-width: 100%;
            word-break: break-word;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        .toast.info {
            border-left: 4px solid var(--primary);
        }

        .toast.warning {
            border-left: 4px solid var(--warning);
        }

        .toast-close {
            margin-left: auto;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .toast-close:hover {
            opacity: 1;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s infinite linear;
        }

        .difficulty-slider {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
            outline: none;
        }

        .difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--light);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .difficulty-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--light);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: none;
        }

        .difficulty-value {
            text-align: center;
            font-weight: bold;
            color: var(--primary);
            margin-top: 5px;
        }

        .blockchain-visualization {
            display: flex;
            overflow-x: auto;
            padding: 20px 0;
            gap: 10px;
            align-items: center;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--card-bg);
        }

        .blockchain-visualization::-webkit-scrollbar {
            height: 8px;
        }

        .blockchain-visualization::-webkit-scrollbar-track {
            background: var(--card-bg);
        }

        .blockchain-visualization::-webkit-scrollbar-thumb {
            background-color: var(--primary);
            border-radius: 20px;
        }

        .vis-block {
            min-width: 100px;
            height: 60px;
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .vis-block:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .vis-block::after {
            content: '';
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 2px;
            background-color: var(--primary);
        }

        .vis-block:last-child::after {
            display: none;
        }

        .vis-block-index {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
        }

        .vis-block-tx {
            font-size: 12px;
            color: var(--light);
            opacity: 0.7;
        }

        .vis-block.genesis {
            background-color: var(--primary);
            color: var(--dark);
        }

        .vis-block.genesis .vis-block-tx {
            color: var(--dark);
            opacity: 0.8;
        }

        .vis-block.mining {
            animation: pulse 1s infinite;
            border: 1px dashed var(--warning);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideInRight {
            from { transform: translateX(120%); }
            to { transform: translateX(0); }
        }

        @keyframes slideOutRight {
            from { transform: translateX(0); }
            to { transform: translateX(120%); }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .mining-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mining-animation.active {
            opacity: 1;
        }

        .mining-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--primary);
            border-radius: 50%;
            opacity: 0.7;
            animation: float 3s infinite ease-in-out;
        }

        @keyframes float {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                transform: translateY(-100px) translateX(50px);
                opacity: 0;
            }
        }

        .debug-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .debug-panel.active {
            display: block;
        }

        .debug-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--card-border);
        }

        .debug-entry:last-child {
            border-bottom: none;
        }

        .debug-time {
            color: var(--primary);
            font-weight: bold;
        }

        .debug-message {
            color: var(--light);
        }

        .debug-error {
            color: var(--danger);
        }

        .debug-success {
            color: var(--success);
        }

        .debug-warning {
            color: var(--warning);
        }

        .merkle-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        .merkle-node {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .merkle-leaf {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            text-align: center;
            min-width: 100px;
        }

        .merkle-hash {
            color: var(--primary);
            font-size: 10px;
            word-break: break-all;
        }

        .merkle-connector {
            position: relative;
            width: 100%;
            height: 20px;
        }

        .merkle-connector::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 20px;
            background-color: var(--primary);
        }

        .whitepaper-section {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--card-bg);
            border-radius: 10px;
            border: 1px solid var(--card-border);
        }

        .whitepaper-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 20px;
            text-align: center;
        }

        .whitepaper-author {
            font-style: italic;
            text-align: center;
            margin-bottom: 20px;
            color: var(--text);
        }

        .whitepaper-content {
            line-height: 1.8;
            text-align: justify;
        }

        .whitepaper-content p {
            margin-bottom: 15px;
        }

        .whitepaper-content h2 {
            color: var(--primary);
            margin: 30px 0 15px;
            font-size: 20px;
        }

        .mining-explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
        }

        .mining-explanation h3 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .mining-explanation p {
            margin-bottom: 10px;
        }

        .mining-explanation code {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }

        .mining-progress {
            margin-top: 15px;
        }

        .progress-bar-container {
            width: 100%;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        .mining-segments {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .segment-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .segment {
            width: 80px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .segment.active {
            background-color: rgba(247, 147, 26, 0.2);
            border-color: var(--primary);
        }

        .segment.completed {
            background-color: rgba(92, 184, 92, 0.2);
            border-color: var(--success);
        }

        .segment.locked {
            background-color: rgba(77, 77, 77, 0.2);
            opacity: 0.7;
        }

        .segment-value {
            font-size: 16px;
            font-weight: bold;
            color: var(--primary);
        }

        .segment.completed .segment-value {
            color: var(--success);
        }

        .segment.locked .segment-value {
            color: var(--secondary);
        }

        .segment-label {
            font-size: 12px;
            color: var(--light);
            opacity: 0.7;
        }

        .segment-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background-color: var(--primary);
            width: 0%;
        }

        .segment.active .segment-progress {
            animation: pulse 1s infinite;
        }

        .mining-reward {
            margin-top: 15px;
            text-align: center;
        }

        .mining-reward-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }

        .mining-reward-label {
            font-size: 14px;
            color: var(--light);
            opacity: 0.7;
        }

        .pow-visualization {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
        }

        .pow-visualization h3 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .pow-step {
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .pow-step-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .pow-step-content {
            font-family: monospace;
            word-break: break-all;
        }

        .pow-target {
            color: var(--success);
        }

        .pow-hash {
            color: var(--warning);
        }

        .pow-match {
            color: var(--success);
            font-weight: bold;
        }

        .pow-nomatch {
            color: var(--danger);
        }

        .current-segment-info {
            margin-top: 15px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
            text-align: center;
        }

        .current-segment-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .current-segment-progress {
            margin-top: 10px;
        }

        .current-segment-time {
            font-size: 14px;
            color: var(--light);
            margin-top: 10px;
        }

        .next-segment-time {
            font-size: 14px;
            color: var(--light);
            margin-top: 5px;
            opacity: 0.7;
        }

        /* New styles for email verification and plan selection */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--card-border);
            max-width: 90%;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: fadeIn 0.3s ease-out;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-content {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text);
        }

        .form-input {
            width: 100%;
            padding: 12px 15px;
            border-radius: 5px;
            border: 1px solid var(--card-border);
            background-color: rgba(0, 0, 0, 0.2);
            color: var(--text);
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .form-input:focus {
            border-color: var(--primary);
        }

        .form-input::placeholder {
            color: rgba(224, 224, 224, 0.5);
        }

        .form-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .plan-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .plan-table th, .plan-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--card-border);
        }

        .plan-table th {
            color: var(--primary);
            font-weight: bold;
        }

        .plan-table tr:last-child td {
            border-bottom: none;
        }

        .plan-table tr:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .plan-table .btn {
            margin: 0;
            padding: 8px 12px;
            font-size: 14px;
        }

        .error-message {
            color: var(--danger);
            background-color: rgba(217, 83, 79, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid var(--danger);
            text-align: center;
        }
        
        .success-message {
            color: var(--success);
            background-color: rgba(92, 184, 92, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid var(--success);
            text-align: center;
        }
        
        .total-earnings {
            font-weight: bold;
            color: var(--success);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">₿</div>
                <div class="logo-text">Bitcoin Mining Simulator</div>
            </div>
            <div class="network-status">
                <div class="status-indicator"></div>
                <span id="network-status-text">Connected</span>
            </div>
        </header>

        <div class="network-stats">
            <div class="stat-card">
                <div class="stat-value" id="network-difficulty">4</div>
                <div class="stat-label">Difficulty</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="network-hashrate">0 H/s</div>
                <div class="stat-label">Network Hashrate</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="blocks-mined">0</div>
                <div class="stat-label">Blocks Mined</div>
            </div>
        </div>

        <div class="blockchain-visualization" id="blockchain-visualization">
            <!-- Visualization will be populated by JavaScript -->
        </div>

        <div class="dashboard">
            <div class="left-column">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Mining Control</div>
                    </div>
                    <div class="mining-section">
                        <div class="mining-status">
                            <div class="mining-indicator" id="mining-indicator"></div>
                            <span id="mining-status">Idle</span>
                        </div>
                        <div class="mining-stats">
                            <div class="stat-card">
                                <div class="stat-value" id="hashrate">0 H/s</div>
                                <div class="stat-label">Hashrate</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="nonce">0</div>
                                <div class="stat-label">Current Nonce</div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="difficulty-slider">Mining Difficulty</label>
                            <input type="range" class="difficulty-slider" id="difficulty-slider"  min="1" max="6" value="4">
                            <div class="difficulty-value" id="difficulty-value">4</div>
                        </div>
                        
                        <div class="current-segment-info">
                            <div class="current-segment-title">Current Mining Segment: <span id="current-segment">1</span> of 6</div>
                            <div class="current-segment-progress">
                                <div class="progress-bar-container">
                                    <div class="progress-bar" id="segment-progress-bar" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="current-segment-time" id="segment-time-remaining">Time remaining: 01:00:00</div>
                            <div class="next-segment-time" id="next-segment-time">Next segment available in: 00:00:00</div>
                        </div>
                        
                        <div class="mining-segments">
                            <div class="segment-container" id="segment-container">
                                <!-- Segments will be populated by JavaScript -->
                            </div>
                        </div>
                        
                        <div class="mining-reward">
                            <div class="mining-reward-value" id="mining-reward">0.000000 BTC</div>
                            <div class="mining-reward-label">Total Mined Today</div>
                        </div>
                        <div class="mining-actions">
                            <button class="btn btn-success" id="start-mining-btn">Start Mining</button>
                            <button class="btn btn-danger" id="stop-mining-btn" disabled>Stop Mining</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Proof-of-Work Visualization</div>
                    </div>
                    <div class="pow-visualization" id="pow-visualization">
                        <h3>Current Mining Process</h3>
                        <div class="pow-step">
                            <div class="pow-step-title">Block Data:</div>
                            <div class="pow-step-content" id="pow-block-data">...</div>
                        </div>
                        <div class="pow-step">
                            <div class="pow-step-title">Target:</div>
                            <div class="pow-step-content">Hash must start with <span class="pow-target" id="pow-target">0000</span></div>
                        </div>
                        <div class="pow-step">
                            <div class="pow-step-title">Current Hash:</div>
                            <div class="pow-step-content"><span class="pow-hash" id="pow-current-hash">...</span></div>
                        </div>
                        <div class="pow-step">
                            <div class="pow-step-title">Result:</div>
                            <div class="pow-step-content" id="pow-result">Searching for valid hash...</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Mining Explanation</div>
                    </div>
                    <div class="mining-explanation">
                        <h3>What is Bitcoin Mining?</h3>
                        <p>Bitcoin mining is the process of adding transaction records to Bitcoin's public ledger of past transactions (the blockchain). This ledger of past transactions is called the blockchain as it is a chain of blocks.</p>
                        
                        <h3>How Proof-of-Work Functions</h3>
                        <p>The proof-of-work system requires miners to find a number called a "nonce". When this nonce is combined with the block data and hashed, it produces a hash that meets specific criteria - typically starting with a certain number of zeros.</p>
                        
                        <p>The steps are:</p>
                        <ol>
                            <li>Take the block data (previous hash, timestamp, transactions, etc.)</li>
                            <li>Add a nonce (starting from 0)</li>
                            <li>Calculate the SHA-256 hash of this combined data</li>
                            <li>Check if the hash meets the difficulty target (starts with a specific number of zeros)</li>
                            <li>If not, increment the nonce and try again</li>
                        </ol>
                        
                        <p>This process requires significant computational power, which secures the network by making it economically impractical to attack.</p>
                    </div>
                </div>
            </div>

            <div class="right-column">
                <div class="card">
                    <div class="tabs">
                        <div class="tab active" data-tab="blockchain">Blockchain</div>
                        <div class="tab" data-tab="merkle">Merkle Tree</div>
                        <div class="tab" data-tab="whitepaper">Whitepaper</div>
                    </div>

                    <div class="tab-content active" id="blockchain-tab">
                        <div class="blockchain-section" id="blockchain-container">
                            <!-- Blockchain will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="tab-content" id="merkle-tab">
                        <div class="merkle-tree" id="merkle-tree">
                            <!-- Merkle tree will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="tab-content" id="whitepaper-tab">
                        <div class="whitepaper-section">
                            <div class="whitepaper-title">Bitcoin: A Peer-to-Peer Electronic Cash System</div>
                            <div class="whitepaper-author">Satoshi Nakamoto</div>
                            <div class="whitepaper-content">
                                <p>
                                    A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network.
                                </p>
                                <p>
                                    The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power.
                                </p>
                                <h2>4. Proof-of-Work</h2>
                                <p>
                                    To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash, rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash.
                                </p>
                                <p>
                                    For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container">
        <!-- Toasts will be added by JavaScript -->
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loader"></div>
    </div>

    <!-- Mining Animation -->
    <div class="mining-animation" id="mining-animation">
        <!-- Mining particles will be added by JavaScript -->
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debug-panel">
        <!-- Debug messages will be added by JavaScript -->
    </div>

    <!-- Email Verification Modal -->
    <div class="modal-overlay" id="email-modal">
        <div class="modal">
            <div class="modal-close" id="email-modal-close">&times;</div>
            <div class="modal-title">Enter Your Email</div>
            <div class="modal-content">
                <div class="form-group">
                    <label class="form-label" for="email-input">Email Address</label>
                    <input type="email" class="form-input" id="email-input" placeholder="Enter your email address">
                </div>
                <div class="form-actions">
                    <button class="btn btn-primary" id="email-proceed-btn">Proceed</button>
                    <button class="btn btn-secondary" id="email-cancel-btn">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Plan Selection Modal -->
    <div class="modal-overlay" id="plan-modal">
        <div class="modal">
            <div class="modal-close" id="plan-modal-close">&times;</div>
            <div class="modal-title">Select a Mining Plan</div>
            <div class="modal-content">
                <p>Choose a mining plan to start earning Bitcoin:</p>
                <table class="plan-table">
                    <thead>
                        <tr>
                            <th>Plan</th>
                            <th>Price</th>
                            <th>Daily Earnings</th>
                            <th>Weekly Earnings</th>
                            <th>Total Earnings</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1-Week Plan</td>
                            <td>$20 USD</td>
                            <td>$6 USD</td>
                            <td>$42 USD</td>
                            <td class="total-earnings">$48 USD</td>
                            <td><button class="btn btn-primary buy-plan-btn" data-plan="1-week" data-price="20">Buy Plan</button></td>
                        </tr>
                        <tr>
                            <td>2-Week Plan</td>
                            <td>$40 USD</td>
                            <td>$6 USD</td>
                            <td>$84 USD</td>
                            <td class="total-earnings">$90 USD</td>
                            <td><button class="btn btn-primary buy-plan-btn" data-plan="2-week" data-price="40">Buy Plan</button></td>
                        </tr>
                        <tr>
                            <td>3-Week Plan</td>
                            <td>$60 USD</td>
                            <td>$6 USD</td>
                            <td>$126 USD</td>
                            <td class="total-earnings">$132 USD</td>
                            <td><button class="btn btn-primary buy-plan-btn" data-plan="3-week" data-price="60">Buy Plan</button></td>
                        </tr>
                        <tr>
                            <td>1-Month Plan</td>
                            <td>$80 USD</td>
                            <td>$6 USD</td>
                            <td>$168 USD</td>
                            <td class="total-earnings">$174 USD</td>
                            <td><button class="btn btn-primary buy-plan-btn" data-plan="1-month" data-price="80">Buy Plan</button></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Insufficient Balance Modal -->
    <div class="modal-overlay" id="balance-modal">
        <div class="modal">
            <div class="modal-close" id="balance-modal-close">&times;</div>
            <div class="modal-title">Insufficient Balance</div>
            <div class="modal-content">
                <div class="error-message">
                    Your account balance is too low to purchase a Bitcoin mining plan. Please click the deposit button below to fund your account.
                </div>
                <div class="form-actions">
                    <button class="btn btn-warning" id="deposit-btn">Deposit</button>
                    <button class="btn btn-secondary" id="balance-cancel-btn">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Purchase Success Modal -->
    <div class="modal-overlay" id="success-modal">
        <div class="modal">
            <div class="modal-close" id="success-modal-close">&times;</div>
            <div class="modal-title">Purchase Successful</div>
            <div class="modal-content">
                <div class="success-message">
                    Your mining plan has been purchased successfully! You can now start mining Bitcoin.
                </div>
                <div class="form-actions">
                    <button class="btn btn-success" id="start-mining-now-btn">Start Mining Now</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Bitcoin Mining Simulator Implementation
        class MerkleTree {
            constructor(transactions) {
                this.transactions = transactions;
                this.tree = this.buildTree();
            }

            buildTree() {
                // If no transactions, return empty tree
                if (this.transactions.length === 0) {
                    return [];
                }

                // Get transaction hashes as leaves
                let leaves = this.transactions.map(tx => tx.hash);
                
                // If odd number of leaves, duplicate the last one
                if (leaves.length % 2 === 1) {
                    leaves.push(leaves[leaves.length - 1]);
                }

                // Build tree bottom-up
                let tree = [leaves];
                let level = leaves;

                while (level.length > 1) {
                    let nextLevel = [];
                    
                    for (let i = 0; i < level.length; i += 2) {
                        const left = level[i];
                        const right = level[i + 1];
                        const combined = left + right;
                        const hash = CryptoJS.SHA256(combined).toString();
                        nextLevel.push(hash);
                    }
                    
                    // If odd number of nodes, duplicate the last one
                    if (nextLevel.length % 2 === 1 && nextLevel.length > 1) {
                        nextLevel.push(nextLevel[nextLevel.length - 1]);
                    }
                    
                    tree.push(nextLevel);
                    level = nextLevel;
                }

                return tree;
            }

            getRoot() {
                if (this.tree.length === 0) return null;
                return this.tree[this.tree.length - 1][0];
            }
        }

        class Transaction {
            constructor(fromAddress, toAddress, amount, timestamp = Date.now()) {
                this.fromAddress = fromAddress;
                this.toAddress = toAddress;
                this.amount = amount;
                this.timestamp = timestamp;
                this.hash = this.calculateHash();
            }

            calculateHash() {
                return CryptoJS.SHA256(
                    this.fromAddress +
                    this.toAddress +
                    this.amount +
                    this.timestamp
                ).toString();
            }
        }

        class Block {
            constructor(timestamp, transactions, previousHash = '') {
                this.timestamp = timestamp;
                this.transactions = transactions;
                this.previousHash = previousHash;
                this.nonce = 0;
                this.merkleRoot = this.calculateMerkleRoot();
                this.hash = this.calculateHash();
            }

            calculateMerkleRoot() {
                const merkleTree = new MerkleTree(this.transactions);
                return merkleTree.getRoot() || '0';
            }

            calculateHash() {
                return CryptoJS.SHA256(
                    this.previousHash +
                    this.timestamp +
                    this.merkleRoot +
                    this.nonce
                ).toString();
            }

            mineBlock(difficulty) {
                const target = Array(difficulty + 1).join('0');
                
                while (this.hash.substring(0, difficulty) !== target) {
                    this.nonce++;
                    this.hash = this.calculateHash();
                    
                    // Yield to UI thread occasionally
                    if (this.nonce % 100 === 0) {
                        return false; // Not done yet
                    }
                }
                
                return true; // Block mined
            }

            getMerkleTree() {
                return new MerkleTree(this.transactions);
            }
        }

        class Blockchain {
            constructor() {
                this.chain = [this.createGenesisBlock()];
                this.difficulty = 4;
                this.miningReward = 0.0000106667; // $1 worth of BTC (1/6 of daily limit)
                this.blockTime = 10000; // Target time between blocks in ms
                this.lastBlockTime = Date.now();
                
                debug('Blockchain initialized with genesis block', 'success');
            }

            createGenesisBlock() {
                return new Block(Date.now(), [], '0');
            }

            getLatestBlock() {
                return this.chain[this.chain.length - 1];
            }

            minePendingTransactions(minerAddress) {
                try {
                    // Create coinbase transaction (mining reward)
                    const rewardTx = new Transaction('Coinbase', minerAddress, this.miningReward);
                    
                    // Create new block
                    const block = new Block(Date.now(), [rewardTx], this.getLatestBlock().hash);
                    
                    // Mine block
                    const mined = block.mineBlock(this.difficulty);
                    
                    if (mined) {
                        // Add block to chain
                        this.chain.push(block);
                        
                        // Adjust difficulty based on block time
                        this.adjustDifficulty();
                        
                        debug(`Block mined successfully: ${block.hash.substring(0, 10)}...`, 'success');
                        return true;
                    }
                    
                    return false;
                } catch (error) {
                    debug('Error mining block: ' + error.message, 'error');
                    return false;
                }
            }

            adjustDifficulty() {
                const currentTime = Date.now();
                const timeElapsed = currentTime - this.lastBlockTime;
                
                if (timeElapsed < this.blockTime / 2) {
                    // Blocks are being mined too quickly, increase difficulty
                    this.difficulty = Math.min(this.difficulty + 1, 6);
                    debug(`Difficulty increased to ${this.difficulty}`, 'info');
                } else if (timeElapsed > this.blockTime * 2) {
                    // Blocks are being mined too slowly, decrease difficulty
                    this.difficulty = Math.max(this.difficulty - 1, 1);
                    debug(`Difficulty decreased to ${this.difficulty}`, 'info');
                }
                
                this.lastBlockTime = currentTime;
            }

            isChainValid() {
                for (let i = 1; i < this.chain.length; i++) {
                    const currentBlock = this.chain[i];
                    const previousBlock = this.chain[i - 1];
                    
                    try {
                        // Validate hash
                        if (currentBlock.hash !== currentBlock.calculateHash()) {
                            debug(`Invalid block hash at height ${i}`, 'error');
                            return false;
                        }
                        
                        // Validate previous hash reference
                        if (currentBlock.previousHash !== previousBlock.hash) {
                            debug(`Invalid previous hash reference at height ${i}`, 'error');
                            return false;
                        }
                        
                        // Validate merkle root
                        if (currentBlock.merkleRoot !== currentBlock.calculateMerkleRoot()) {
                            debug(`Invalid merkle root at height ${i}`, 'error');
                            return false;
                        }
                    } catch (error) {
                        debug('Chain validation error: ' + error.message, 'error');
                        return false;
                    }
                }
                
                debug('Blockchain validated successfully', 'success');
                return true;
            }
        }

        class Miner {
            constructor(blockchain) {
                this.blockchain = blockchain;
                this.mining = false;
                this.hashrate = 0;
                this.startTime = 0;
                this.hashCount = 0;
                this.blocksMined = 0;
                this.totalMined = 0;
                this.minerAddress = 'MinerAddress';
                this.currentNonce = 0;
                this.currentHash = '';
                
                // Segment-based mining (6 segments of $1 each)
                this.segments = [
                    { id: 1, value: 1, completed: false, active: false, locked: false, startTime: null, endTime: null },
                    { id: 2, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null },
                    { id: 3, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null },
                    { id: 4, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null },
                    { id: 5, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null },
                    { id: 6, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null }
                ];
                this.currentSegment = 0;
                this.segmentDuration = 60 * 60 * 1000; // 1 hour in milliseconds
                this.segmentProgress = 0;
                this.segmentStartTime = null;
                
                // User data
                this.userEmail = '';
                this.userPlan = '';
                this.userBalance = 0;
                
                // Initialize segments
                this.initializeSegments();
            }

            initializeSegments() {
                // First segment is unlocked by default
                this.segments[0].locked = false;
                
                // Check if any segments were previously started
                const savedSegments = localStorage.getItem('miningSegments');
                if (savedSegments) {
                    try {
                        const parsedSegments = JSON.parse(savedSegments);
                        this.segments = parsedSegments;
                        
                        // Find current active segment
                        const activeSegment = this.segments.find(segment => segment.active);
                        if (activeSegment) {
                            this.currentSegment = activeSegment.id - 1;
                            this.segmentStartTime = activeSegment.startTime;
                            
                            // Calculate progress
                            const now = Date.now();
                            const elapsed = now - this.segmentStartTime;
                            this.segmentProgress = Math.min(elapsed / this.segmentDuration, 1);
                            
                            // If segment should be completed
                            if (this.segmentProgress >= 1) {
                                this.completeCurrentSegment();
                            }
                        } else {
                            // Find the next uncompleted segment
                            const nextSegment = this.segments.find(segment => !segment.completed && !segment.locked);
                            if (nextSegment) {
                                this.currentSegment = nextSegment.id - 1;
                            }
                        }
                        
                        // Calculate total mined
                        this.totalMined = this.segments.filter(segment => segment.completed)
                            .reduce((total, segment) => total + this.blockchain.miningReward, 0);
                    } catch (error) {
                        debug('Error loading saved segments: ' + error.message, 'error');
                        localStorage.removeItem('miningSegments');
                    }
                }
                
                // Check if user has a saved plan
                const savedPlan = localStorage.getItem('userPlan');
                if (savedPlan) {
                    try {
                        const planData = JSON.parse(savedPlan);
                        this.userPlan = planData.plan;
                        this.userEmail = planData.email;
                        debug(`Loaded saved plan: ${this.userPlan} for ${this.userEmail}`, 'info');
                    } catch (error) {
                        debug('Error loading saved plan: ' + error.message, 'error');
                        localStorage.removeItem('userPlan');
                    }
                }
                
                this.updateSegmentsUI();
            }

            saveSegments() {
                localStorage.setItem('miningSegments', JSON.stringify(this.segments));
            }
            
            savePlan(email, plan) {
                this.userEmail = email;
                this.userPlan = plan;
                localStorage.setItem('userPlan', JSON.stringify({
                    email: email,
                    plan: plan,
                    purchaseDate: Date.now()
                }));
                debug(`Saved plan: ${plan} for ${email}`, 'info');
            }

            startMining() {
                // Check if all segments are completed
                const allCompleted = this.segments.every(segment => segment.completed);
                if (allCompleted) {
                    showToast('All mining segments completed for today. Try again tomorrow.', 'warning');
                    return false;
                }
                
                // Find the next available segment
                const nextSegment = this.segments.find(segment => !segment.completed && !segment.locked);
                if (!nextSegment) {
                    showToast('No available mining segments. Wait for the next segment to unlock.', 'warning');
                    return false;
                }
                
                this.currentSegment = nextSegment.id - 1;
                this.segments[this.currentSegment].active = true;
                this.segmentStartTime = Date.now();
                this.segments[this.currentSegment].startTime = this.segmentStartTime;
                this.segmentProgress = 0;
                
                this.mining = true;
                this.startTime = Date.now();
                this.hashCount = 0;
                
                // Save segments state
                this.saveSegments();
                
                // Start mining animation
                startMiningAnimation();
                
                this.mineNextBlock();
                
                debug(`Mining started for segment ${this.currentSegment + 1}`, 'info');
                return true;
            }

            stopMining() {
                this.mining = false;
                
                // Update segment state
                if (this.currentSegment >= 0 && this.currentSegment < this.segments.length) {
                    this.segments[this.currentSegment].active = false;
                    this.saveSegments();
                }
                
                // Stop mining animation
                stopMiningAnimation();
                
                debug('Mining stopped', 'info');
            }

            mineNextBlock() {
                if (!this.mining) return;
                
                try {
                    // Check if segment is completed
                    const now = Date.now();
                    const elapsed = now - this.segmentStartTime;
                    this.segmentProgress = Math.min(elapsed / this.segmentDuration, 1);
                    
                    // Update UI
                    updateSegmentProgress(this.segmentProgress);
                    
                    // If segment is completed
                    if (this.segmentProgress >= 1) {
                        this.completeCurrentSegment();
                        return;
                    }

                    // Create a new block to mine
                    const latestBlock = this.blockchain.getLatestBlock();
                    const rewardTx = new Transaction('Coinbase', this.minerAddress, this.blockchain.miningReward);
                    const block = new Block(Date.now(), [rewardTx], latestBlock.hash);
                    
                    // Try to find a valid hash
                    const target = Array(this.blockchain.difficulty + 1).join('0');
                    
                    // Update UI with current mining attempt
                    this.currentNonce = block.nonce;
                    this.currentHash = block.hash;
                    document.getElementById('nonce').textContent = this.currentNonce;
                    document.getElementById('pow-block-data').textContent = `PrevHash: ${block.previousHash.substring(0, 10)}..., Timestamp: ${block.timestamp}, MerkleRoot: ${block.merkleRoot.substring(0, 10)}...`;
                    document.getElementById('pow-target').textContent = target;
                    document.getElementById('pow-current-hash').textContent = this.currentHash;
                    
                    if (this.currentHash.substring(0, this.blockchain.difficulty) === target) {
                        document.getElementById('pow-result').innerHTML = `<span class="pow-match">MATCH FOUND!</span>`;
                    } else {
                        document.getElementById('pow-result').innerHTML = `<span class="pow-nomatch">No match yet, continuing...</span>`;
                    }
                    
                    // Increment nonce and calculate new hash
                    block.nonce++;
                    block.hash = block.calculateHash();
                    
                    // Increment hash count
                    this.hashCount += 1;
                    
                    // Check if we found a valid hash
                    if (block.hash.substring(0, this.blockchain.difficulty) === target) {
                        // Block successfully mined
                        this.blocksMined++;
                        
                        // Add block to blockchain
                        this.blockchain.chain.push(block);
                        
                        showToast(`Block mined successfully!`, 'success');
                        updateBlockchainDisplay();
                        updateMerkleTreeDisplay();
                        
                        // Play mining success animation
                        playMiningSuccessAnimation();
                        
                        // Calculate hashrate
                        const endTime = Date.now();
                        const timeElapsed = (endTime - this.startTime) / 1000; // in seconds
                        this.hashrate = Math.round(this.hashCount / timeElapsed);
                        
                        // Reset for next block
                        this.startTime = Date.now();
                        this.hashCount = 0;
                    }
                    
                    // Update hashrate every second
                    const currentTime = Date.now();
                    if (currentTime - this.startTime > 1000) {
                        const timeElapsed = (currentTime - this.startTime) / 1000;
                        this.hashrate = Math.round(this.hashCount / timeElapsed);
                        document.getElementById('hashrate').textContent = formatHashrate(this.hashrate);
                    }
                    
                    // Continue mining
                    if (this.mining) {
                        setTimeout(() => this.mineNextBlock(), 0);
                    }
                } catch (error) {
                    debug('Mining error: ' + error.message, 'error');
                    showToast('Mining error: ' + error.message, 'error');
                    this.stopMining();
                }
            }

            completeCurrentSegment() {
                if (this.currentSegment < 0 || this.currentSegment >= this.segments.length) return;
                
                // Mark current segment as completed
                this.segments[this.currentSegment].completed = true;
                this.segments[this.currentSegment].active = false;
                this.segments[this.currentSegment].endTime = Date.now();
                
                // Add reward
                this.totalMined += this.blockchain.miningReward;
                
                // Unlock next segment if available
                if (this.currentSegment + 1 < this.segments.length) {
                    this.segments[this.currentSegment + 1].locked = false;
                    this.segments[this.currentSegment + 1].startTime = Date.now() + this.segmentDuration; // Available in 1 hour
                }
                
                // Save segments state
                this.saveSegments();
                
                // Update UI
                this.updateSegmentsUI();
                updateMiningReward();
                
                // Stop mining
                this.stopMining();
                
                // Update user balance in Baserow
                this.updateUserBalance(1); // $1 per segment
                
                showToast(`Mining segment ${this.currentSegment + 1} completed! Earned $1 worth of BTC.`, 'success');
                debug(`Mining segment ${this.currentSegment + 1} completed`, 'success');
            }
            
            updateUserBalance(amount) {
                // Update user balance in Baserow
                if (this.userEmail) {
                    debug(`Updating balance for ${this.userEmail} with +$${amount}`, 'info');
                    
                    // Simulate API call to Baserow to update balance
                    fetch('https://api.baserow.io/api/database/rows/table/3849413/', {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Token YOUR_API_TOKEN'
                        },
                        body: JSON.stringify({
                            // Find the user by email and update their balance
                            // This is a simplified example - in a real implementation,
                            // you would need to get the row ID first
                            'email': this.userEmail,
                            'total_assets': { 'add': amount }
                        })
                    })
                    .then(response => {
                        if (response.ok) {
                            debug(`Balance updated successfully for ${this.userEmail}`, 'success');
                        } else {
                            debug(`Failed to update balance for ${this.userEmail}`, 'error');
                        }
                    })
                    .catch(error => {
                        debug(`Error updating balance: ${error.message}`, 'error');
                    });
                }
            }

            updateSegmentsUI() {
                const segmentContainer = document.getElementById('segment-container');
                segmentContainer.innerHTML = '';
                
                this.segments.forEach((segment, index) => {
                    const segmentElement = document.createElement('div');
                    segmentElement.className = 'segment';
                    
                    if (segment.completed) {
                        segmentElement.classList.add('completed');
                    } else if (segment.active) {
                        segmentElement.classList.add('active');
                    } else if (segment.locked) {
                        segmentElement.classList.add('locked');
                    }
                    
                    segmentElement.innerHTML = `
                        <div class="segment-value">$${segment.value}</div>
                        <div class="segment-label">${segment.completed ? 'Completed' : segment.active ? 'Mining' : segment.locked ? 'Locked' : 'Available'}</div>
                        ${segment.active ? `<div class="segment-progress" style="width: ${this.segmentProgress * 100}%"></div>` : ''}
                    `;
                    
                    segmentContainer.appendChild(segmentElement);
                });
                
                // Update current segment info
                document.getElementById('current-segment').textContent = this.currentSegment + 1;
                
                // Update next segment time
                this.updateNextSegmentTime();
            }

            updateNextSegmentTime() {
                // Find the next locked segment
                const nextLockedSegment = this.segments.find(segment => segment.locked && segment.startTime);
                
                if (nextLockedSegment) {
                    const now = Date.now();
                    const timeRemaining = Math.max(0, nextLockedSegment.startTime - now);
                    
                    if (timeRemaining > 0) {
                        const hours = Math.floor(timeRemaining / (60 * 60 * 1000));
                        const minutes = Math.floor((timeRemaining % (60 * 60 * 1000)) / (60 * 1000));
                        const seconds = Math.floor((timeRemaining % (60 * 1000)) / 1000);
                        
                        document.getElementById('next-segment-time').textContent = `Next segment available in: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // Unlock the segment
                        nextLockedSegment.locked = false;
                        this.saveSegments();
                        this.updateSegmentsUI();
                    }
                } else {
                    document.getElementById('next-segment-time').textContent = 'All segments available';
                }
            }

            checkSegmentUnlocks() {
                let updated = false;
                
                this.segments.forEach(segment => {
                    if (segment.locked && segment.startTime && Date.now() >= segment.startTime) {
                        segment.locked = false;
                        updated = true;
                    }
                });
                
                if (updated) {
                    this.saveSegments();
                    this.updateSegmentsUI();
                    showToast('New mining segment unlocked!', 'success');
                }
            }

            getTimeRemainingInSegment() {
                if (!this.segmentStartTime || this.currentSegment < 0 || !this.segments[this.currentSegment].active) {
                    return '00:00:00';
                }
                
                const now = Date.now();
                const elapsed = now - this.segmentStartTime;
                const remaining = Math.max(0, this.segmentDuration - elapsed);
                
                // Convert to hours, minutes, seconds
                const hours = Math.floor(remaining / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                const seconds = Math.floor((remaining % (60 * 1000)) / 1000);
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            getHashrate() {
                return this.hashrate;
            }

            getBlocksMined() {
                return this.blocksMined;
            }

            getTotalMined() {
                return this.totalMined;
            }

            resetSegments() {
                this.segments = [
                    { id: 1, value: 1, completed: false, active: false, locked: false, startTime: null, endTime: null },
                    { id: 2, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null },
                    { id: 3, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null },
                    { id: 4, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null },
                    { id: 5, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null },
                    { id: 6, value: 1, completed: false, active: false, locked: true, startTime: null, endTime: null }
                ];
                this.currentSegment = 0;
                this.totalMined = 0;
                this.saveSegments();
                this.updateSegmentsUI();
                updateMiningReward();
                
                showToast('Mining segments reset for a new day', 'info');
                debug('Mining segments reset', 'info');
            }
        }

        // Debug function
        function debug(message, type = 'info') {
            const debugPanel = document.getElementById('debug-panel');
            const debugEntry = document.createElement('div');
            debugEntry.className = 'debug-entry';
            
            const time = new Date().toLocaleTimeString();
            debugEntry.innerHTML = `
                <span class="debug-time">[${time}]</span>
                <span class="debug-${type}">${message}</span>
            `;
            
            debugPanel.appendChild(debugEntry);
            
            // Auto-scroll to bottom
            debugPanel.scrollTop = debugPanel.scrollHeight;
            
            // Limit entries
            while (debugPanel.children.length > 50) {
                debugPanel.removeChild(debugPanel.firstChild);
            }
            
            // Log to console as well
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Initialize blockchain
        const bitcoin = new Blockchain();
        const miner = new Miner(bitcoin);

        // DOM elements
        const startMiningButton = document.getElementById('start-mining-btn');
        const stopMiningButton = document.getElementById('stop-mining-btn');
        const miningStatusElement = document.getElementById('mining-status');
        const miningIndicatorElement = document.getElementById('mining-indicator');
        const difficultySlider = document.getElementById('difficulty-slider');
        const difficultyValueElement = document.getElementById('difficulty-value');
        const networkDifficultyElement = document.getElementById('network-difficulty');
        const hashrateElement = document.getElementById('hashrate');
        const networkHashrateElement = document.getElementById('network-hashrate');
        const blocksMined = document.getElementById('blocks-mined');
        const loadingOverlay = document.getElementById('loading-overlay');
        const miningAnimation = document.getElementById('mining-animation');
        const debugPanel = document.getElementById('debug-panel');
        const miningReward = document.getElementById('mining-reward');
        const nonceElement = document.getElementById('nonce');
        const segmentProgressBar = document.getElementById('segment-progress-bar');
        const segmentTimeRemaining = document.getElementById('segment-time-remaining');
        const nextSegmentTime = document.getElementById('next-segment-time');

        // Email verification and plan selection elements
        const emailModal = document.getElementById('email-modal');
        const emailModalClose = document.getElementById('email-modal-close');
        const emailInput = document.getElementById('email-input');
        const emailProceedBtn = document.getElementById('email-proceed-btn');
        const emailCancelBtn = document.getElementById('email-cancel-btn');
        
        const planModal = document.getElementById('plan-modal');
        const planModalClose = document.getElementById('plan-modal-close');
        const buyPlanButtons = document.querySelectorAll('.buy-plan-btn');
        
        const balanceModal = document.getElementById('balance-modal');
        const balanceModalClose = document.getElementById('balance-modal-close');
        const depositBtn = document.getElementById('deposit-btn');
        const balanceCancelBtn = document.getElementById('balance-cancel-btn');
        
        const successModal = document.getElementById('success-modal');
        const successModalClose = document.getElementById('success-modal-close');
        const startMiningNowBtn = document.getElementById('start-mining-now-btn');

        // User data
        let currentUserEmail = '';
        let userBalance = 3849413; // Initial balance from Baserow
        
        // Predefined list of approved emails
        const approvedEmails = [
            'user@example.com',
            'admin@example.com',
            'test@example.com',
            'demo@example.com',
            'mining@example.com'
        ];

        // Event listeners
        startMiningButton.addEventListener('click', showEmailVerification);
        stopMiningButton.addEventListener('click', stopMining);
        difficultySlider.addEventListener('input', updateDifficulty);

        // Email modal event listeners
        emailModalClose.addEventListener('click', closeEmailModal);
        emailCancelBtn.addEventListener('click', closeEmailModal);
        emailProceedBtn.addEventListener('click', verifyEmail);

        // Plan modal event listeners
        planModalClose.addEventListener('click', closePlanModal);
        buyPlanButtons.forEach(button => {
            button.addEventListener('click', function() {
                const plan = this.getAttribute('data-plan');
                const price = parseInt(this.getAttribute('data-price'));
                buyPlan(plan, price);
            });
        });

        // Balance modal event listeners
        balanceModalClose.addEventListener('click', closeBalanceModal);
        balanceCancelBtn.addEventListener('click', closeBalanceModal);
        depositBtn.addEventListener('click', redirectToDeposit);
        
        // Success modal event listeners
        successModalClose.addEventListener('click', closeSuccessModal);
        startMiningNowBtn.addEventListener('click', function() {
            closeSuccessModal();
            startMining();
        });

        // Debug panel toggle (press D key)
        document.addEventListener('keydown', function(event) {
            if (event.key === 'd' || event.key === 'D') {
                debugPanel.classList.toggle('active');
            }
        });

        // Tab switching
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                
                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                const tabContents = document.querySelectorAll('.tab-content');
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                // Update Merkle tree if that tab is selected
                if (tabId === 'merkle') {
                    updateMerkleTreeDisplay();
                }
            });
        });

        // Show email verification modal
        function showEmailVerification() {
            // Check if user already has a plan
            const savedPlan = localStorage.getItem('userPlan');
            if (savedPlan) {
                try {
                    const planData = JSON.parse(savedPlan);
                    currentUserEmail = planData.email;
                    debug(`User already has a plan: ${planData.plan}`, 'info');
                    startMining();
                    return;
                } catch (error) {
                    debug('Error loading saved plan: ' + error.message, 'error');
                    localStorage.removeItem('userPlan');
                }
            }
            
            emailModal.classList.add('active');
            emailInput.focus();
            debug('Email verification modal opened', 'info');
        }

        // Close email modal
        function closeEmailModal() {
            emailModal.classList.remove('active');
            emailInput.value = '';
            debug('Email verification modal closed', 'info');
        }

        // Verify email
        function verifyEmail() {
            const email = emailInput.value.trim();
            
            if (!email) {
                showToast('Please enter your email address', 'error');
                return;
            }
            
            if (!isValidEmail(email)) {
                showToast('Please enter a valid email address', 'error');
                return;
            }
            
            currentUserEmail = email;
            
            // Check if email is in approved list
            if (approvedEmails.includes(email.toLowerCase())) {
                // Email is approved, start mining
                closeEmailModal();
                startMining();
                debug(`Email verified: ${email}`, 'success');
            } else {
                // Email not approved, show plan selection
                closeEmailModal();
                showPlanSelection();
                debug(`Email not in approved list: ${email}`, 'info');
            }
        }

        // Show plan selection modal
        function showPlanSelection() {
            planModal.classList.add('active');
            debug('Plan selection modal opened', 'info');
        }

        // Close plan modal
        function closePlanModal() {
            planModal.classList.remove('active');
            debug('Plan selection modal closed', 'info');
        }

        // Buy plan
        function buyPlan(plan, price) {
            debug(`Attempting to buy ${plan} plan for $${price}`, 'info');
            
            // Check user balance in Baserow
            checkUserBalance(currentUserEmail, price).then(hasBalance => {
                if (hasBalance) {
                    // User has enough balance, deduct the price
                    deductFromBalance(currentUserEmail, price).then(success => {
                        if (success) {
                            // Save plan details to local storage
                            miner.savePlan(currentUserEmail, plan);
                            
                            // Show success modal
                            closePlanModal();
                            showSuccessModal();
                            debug(`Plan purchased: ${plan}`, 'success');
                        } else {
                            showToast('Error processing payment. Please try again.', 'error');
                            debug('Error deducting from balance', 'error');
                        }
                    });
                } else {
                    // User doesn't have enough balance, show deposit modal
                    closePlanModal();
                    showBalanceModal();
                    debug(`Insufficient balance for ${plan} plan`, 'warning');
                }
            });
        }

        // Check user balance
        async function checkUserBalance(email, requiredAmount) {
            debug(`Checking balance for ${email}, required: $${requiredAmount}`, 'info');
            
            // In a real implementation, you would fetch the user's balance from Baserow
            // For this example, we'll use the userBalance variable
            return userBalance >= requiredAmount;
        }
        
        // Deduct from user balance
        async function deductFromBalance(email, amount) {
            debug(`Deducting $${amount} from ${email}'s balance`, 'info');
            
            // In a real implementation, you would update the user's balance in Baserow
            // For this example, we'll update the userBalance variable
            userBalance -= amount;
            
            // Simulate API call to Baserow
            try {
                // This is a simplified example - in a real implementation,
                // you would need to get the row ID first
                fetch('https://api.baserow.io/api/database/rows/table/3849413/', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Token YOUR_API_TOKEN'
                    },
                    body: JSON.stringify({
                        'email': email,
                        'total_assets': userBalance
                    })
                });
                
                debug(`Balance updated to $${userBalance}`, 'success');
                return true;
            } catch (error) {
                debug(`Error updating balance: ${error.message}`, 'error');
                return false;
            }
        }

        // Show success modal
        function showSuccessModal() {
            successModal.classList.add('active');
            debug('Success modal opened', 'info');
        }
        
        // Close success modal
        function closeSuccessModal() {
            successModal.classList.remove('active');
            debug('Success modal closed', 'info');
        }

        // Show insufficient balance modal
        function showBalanceModal() {
            balanceModal.classList.add('active');
            debug('Insufficient balance modal opened', 'info');
        }

        // Close balance modal
        function closeBalanceModal() {
            balanceModal.classList.remove('active');
            debug('Insufficient balance modal closed', 'info');
        }

        // Redirect to deposit page
        function redirectToDeposit() {
            debug('Redirecting to deposit page', 'info');
            window.location.href = 'https://www.bg.cn';
        }

        // Validate email format
        function isValidEmail(email) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return emailRegex.test(email);
        }

        // Start mining
        function startMining() {
            const started = miner.startMining();
            
            if (started) {
                // Update UI
                startMiningButton.disabled = true;
                stopMiningButton.disabled = false;
                miningStatusElement.textContent = 'Mining';
                miningIndicatorElement.classList.add('active');
                
                showToast('Mining started', 'info');
                
                // Start hashrate update interval
                startHashrateInterval();
                
                // Start segment timer
                startSegmentTimer();
            }
        }

        // Stop mining
        function stopMining() {
            miner.stopMining();

            // Update UI
            startMiningButton.disabled = false;
            stopMiningButton.disabled = true;
            miningStatusElement.textContent = 'Idle';
            miningIndicatorElement.classList.remove('active');
            
            showToast('Mining stopped', 'info');
            
            // Stop hashrate update interval
            clearInterval(hashrateInterval);
            
            // Stop segment timer
            clearInterval(segmentTimer);
        }

        // Update difficulty
        function updateDifficulty() {
            const difficulty = parseInt(difficultySlider.value);
            difficultyValueElement.textContent = difficulty;
            bitcoin.difficulty = difficulty;
            networkDifficultyElement.textContent = difficulty;
            document.getElementById('pow-target').textContent = Array(difficulty + 1).join('0');
        }

        // Update segment progress
        function updateSegmentProgress(progress) {
            segmentProgressBar.style.width = `${progress * 100}%`;
            segmentTimeRemaining.textContent = `Time remaining: ${miner.getTimeRemainingInSegment()}`;
            
            // Update segment UI
            miner.updateSegmentsUI();
        }

        // Update mining reward
        function updateMiningReward() {
            miningReward.textContent = `${miner.getTotalMined().toFixed(8)} BTC`;
        }

        // Update blockchain display
        function updateBlockchainDisplay() {
            const blockchainContainer = document.getElementById('blockchain-container');
            const blockchainVisualization = document.getElementById('blockchain-visualization');
            
            // Clear containers
            blockchainContainer.innerHTML = '';
            blockchainVisualization.innerHTML = '';
            
            // Update blockchain visualization
            bitcoin.chain.forEach((block, index) => {
                const blockElement = document.createElement('div');
                blockElement.className = index === 0 ? 'vis-block genesis' : 'vis-block';
                
                blockElement.innerHTML = `
                    <div class="vis-block-index">${index}</div>
                    <div class="vis-block-tx">${block.transactions.length} tx</div>
                `;
                
                blockElement.addEventListener('click', () => {
                    // Find and open the detailed block in the blockchain container
                    const detailedBlock = document.querySelector(`.block[data-index="${index}"] .block-details`);
                    if (detailedBlock) {
                        detailedBlock.classList.add('active');
                        
                        // Switch to blockchain tab
                        document.querySelector('.tab[data-tab="blockchain"]').click();
                        
                        // Scroll to the block
                        detailedBlock.scrollIntoView({ behavior: 'smooth' });
                    }
                });
                
                blockchainVisualization.appendChild(blockElement);
            });
            
            // Add mining block visualization if mining
            if (miner.mining) {
                const miningBlockElement = document.createElement('div');
                miningBlockElement.className = 'vis-block mining';
                
                miningBlockElement.innerHTML = `
                    <div class="vis-block-index">?</div>
                    <div class="vis-block-tx">Mining...</div>
                `;
                
                blockchainVisualization.appendChild(miningBlockElement);
            }
            
            // Update detailed blockchain view
            bitcoin.chain.forEach((block, index) => {
                const blockElement = document.createElement('div');
                blockElement.className = 'block';
                blockElement.setAttribute('data-index', index);
                
                if (index === bitcoin.chain.length - 1) {
                    blockElement.classList.add('new-block');
                }
                
                const blockHeader = document.createElement('div');
                blockHeader.className = 'block-header';
                blockHeader.innerHTML = `
                    <span>Block #${index}</span>
                    <span>${block.hash.substring(0, 10)}...</span>
                `;
                
                blockHeader.addEventListener('click', () => {
                    blockDetails.classList.toggle('active');
                });
                
                const blockDetails = document.createElement('div');
                blockDetails.className = 'block-details';
                blockDetails.innerHTML = `
                    <p><strong>Timestamp:</strong> ${new Date(block.timestamp).toLocaleString()}</p>
                    <p><strong>Hash:</strong> ${block.hash}</p>
                    <p><strong>Previous Hash:</strong> ${block.previousHash}</p>
                    <p><strong>Merkle Root:</strong> ${block.merkleRoot}</p>
                    <p><strong>Nonce:</strong> ${block.nonce}</p>
                    <p><strong>Difficulty:</strong> ${bitcoin.difficulty}</p>
                    <p><strong>Transactions:</strong> ${block.transactions.length}</p>
                `;
                
                if (block.transactions.length > 0) {
                    const transactionsContainer = document.createElement('div');
                    transactionsContainer.className = 'transactions-container';
                    
                    block.transactions.forEach(tx => {
                        const txElement = document.createElement('div');
                        txElement.className = 'transaction';
                        
                        if (index === bitcoin.chain.length - 1) {
                            txElement.classList.add('new-tx');
                        }
                        
                        txElement.innerHTML = `
                            <p><strong>From:</strong> ${tx.fromAddress}</p>
                            <p><strong>To:</strong> ${tx.toAddress}</p>
                            <p><strong>Amount:</strong> ${tx.amount} BTC</p>
                            <p><strong>Hash:</strong> ${tx.hash.substring(0, 15)}...</p>
                        `;
                        
                        transactionsContainer.appendChild(txElement);
                    });
                    
                    blockDetails.appendChild(transactionsContainer);
                }
                
                blockElement.appendChild(blockHeader);
                blockElement.appendChild(blockDetails);
                blockchainContainer.appendChild(blockElement);
            });
            
            // Update blocks mined
            blocksMined.textContent = miner.getBlocksMined();
        }

        // Update Merkle tree display
        function updateMerkleTreeDisplay() {
            const merkleTreeContainer = document.getElementById('merkle-tree');
            merkleTreeContainer.innerHTML = '';
            
            // Get the latest block with transactions
            let latestBlockWithTx = null;
            for (let i = bitcoin.chain.length - 1; i >= 0; i--) {
                if (bitcoin.chain[i].transactions.length > 0) {
                    latestBlockWithTx = bitcoin.chain[i];
                    break;
                }
            }
            
            if (!latestBlockWithTx) {
                merkleTreeContainer.innerHTML = '<p>No blocks with transactions yet</p>';
                return;
            }
            
            // Create Merkle tree
            const merkleTree = latestBlockWithTx.getMerkleTree();
            const tree = merkleTree.tree;
            
            if (tree.length === 0) {
                merkleTreeContainer.innerHTML = '<p>No transactions to build Merkle tree</p>';
                return;
            }
            
            // Create visual representation of the tree
            for (let i = 0; i < tree.length; i++) {
                const level = tree[i];
                const levelDiv = document.createElement('div');
                levelDiv.className = 'merkle-node';
                
                level.forEach(hash => {
                    const leafDiv = document.createElement('div');
                    leafDiv.className = 'merkle-leaf';
                    
                    // For the bottom level (transactions), show tx info
                    if (i === 0) {
                        // Find the transaction for this hash
                        const tx = latestBlockWithTx.transactions.find(tx => tx.hash === hash);
                        if (tx) {
                            leafDiv.innerHTML = `
                                <div>Tx: ${tx.fromAddress} → ${tx.toAddress}</div>
                                <div class="merkle-hash">${hash.substring(0, 10)}...</div>
                            `;
                        } else {
                            leafDiv.innerHTML = `<div class="merkle-hash">${hash.substring(0, 10)}...</div>`;
                        }
                    } else {
                        leafDiv.innerHTML = `<div class="merkle-hash">${hash.substring(0, 10)}...</div>`;
                    }
                    
                    levelDiv.appendChild(leafDiv);
                });
                
                merkleTreeContainer.appendChild(levelDiv);
                
                // Add connectors between levels
                if (i < tree.length - 1) {
                    const connectorDiv = document.createElement('div');
                    connectorDiv.className = 'merkle-connector';
                    merkleTreeContainer.appendChild(connectorDiv);
                }
            }
        }

        // Show loading overlay
        function showLoading() {
            loadingOverlay.classList.add('active');
        }

        // Hide loading overlay
        function hideLoading() {
            loadingOverlay.classList.remove('active');
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            toast.innerHTML = `
                <div>${message}</div>
                <div class="toast-close">&times;</div>
            `;
            
            const closeButton = toast.querySelector('.toast-close');
            closeButton.addEventListener('click', () => {
                toast.style.animation = 'slideOutRight 0.3s forwards';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            });
            
            toastContainer.appendChild(toast);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideOutRight 0.3s forwards';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.remove();
                        }
                    }, 300);
                }
            }, 5000);
        }

        // Format hashrate
        function formatHashrate(hashrate) {
            if (hashrate < 1000) {
                return `${hashrate} H/s`;
            } else if (hashrate < 1000000) {
                return `${(hashrate / 1000).toFixed(2)} KH/s`;
            } else {
                return `${(hashrate / 1000000).toFixed(2)} MH/s`;
            }
        }

        // Start mining animation
        function startMiningAnimation() {
            miningAnimation.classList.add('active');
            
            // Create mining particles
            for (let i = 0; i < 20; i++) {
                createMiningParticle();
            }
            
            // Create particles periodically
            miningParticleInterval = setInterval(() => {
                createMiningParticle();
            }, 300);
        }

        // Create mining particle
        function createMiningParticle() {
            const particle = document.createElement('div');
            particle.className = 'mining-particle';
            
            // Random position
            const x = Math.random() * window.innerWidth;
            const y = window.innerHeight;
            
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            
            // Random animation duration
            const duration = 2 + Math.random() * 3;
            particle.style.animation = `float ${duration}s infinite ease-in-out`;
            
            miningAnimation.appendChild(particle);
            
            // Remove after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.remove();
                }
            }, duration * 1000);
        }

        // Stop mining animation
        function stopMiningAnimation() {
            miningAnimation.classList.remove('active');
            clearInterval(miningParticleInterval);
            
            // Remove all particles
            while (miningAnimation.firstChild) {
                miningAnimation.removeChild(miningAnimation.firstChild);
            }
        }

        // Play mining success animation
        function playMiningSuccessAnimation() {
            // Flash the screen
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'rgba(247, 147, 26, 0.3)';
            flash.style.zIndex = '998';
            flash.style.pointerEvents = 'none';
            
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.remove();
            }, 500);
        }

        // Hashrate update interval
        let hashrateInterval;
        let miningParticleInterval;
        let segmentTimer;
        let segmentUnlockTimer;
        
        function startHashrateInterval() {
            hashrateInterval = setInterval(() => {
                const hashrate = miner.getHashrate();
                hashrateElement.textContent = formatHashrate(hashrate);
                networkHashrateElement.textContent = formatHashrate(hashrate);
                nonceElement.textContent = miner.currentNonce;
            }, 1000);
        }

        function startSegmentTimer() {
            segmentTimer = setInterval(() => {
                if (miner.mining) {
                    const now = Date.now();
                    const elapsed = now - miner.segmentStartTime;
                    const progress = Math.min(elapsed / miner.segmentDuration, 1);
                    
                    updateSegmentProgress(progress);
                    
                    // If segment is completed
                    if (progress >= 1) {
                        miner.completeCurrentSegment();
                    }
                }
            }, 1000);
        }

        function startSegmentUnlockTimer() {
            segmentUnlockTimer = setInterval(() => {
                miner.checkSegmentUnlocks();
                miner.updateNextSegmentTime();
            }, 1000);
        }

        // Initialize the application
        function init() {
            // Update UI
            updateBlockchainDisplay();
            updateMiningReward();
            
            // Set initial difficulty
            difficultySlider.value = bitcoin.difficulty;
            difficultyValueElement.textContent = bitcoin.difficulty;
            networkDifficultyElement.textContent = bitcoin.difficulty;
            
            // Mine a genesis block with a reward
            const genesisBlock = new Block(Date.now(), [new Transaction('Coinbase', 'Genesis', 50)], '0');
            genesisBlock.mineBlock(bitcoin.difficulty);
            bitcoin.chain[0] = genesisBlock;
            
            // Update UI
            updateBlockchainDisplay();
            updateMerkleTreeDisplay();
            
            // Start segment unlock timer
            startSegmentUnlockTimer();
            
            debug('Bitcoin mining simulator initialized and ready', 'success');
            
            // Show debug panel by default to help users
            debugPanel.classList.add('active');
            
            // Show welcome toast
            showToast('Welcome to Bitcoin Mining Simulator! Each $1 segment takes 1 hour to mine.', 'info');
            
            // Check if user already has a plan
            const savedPlan = localStorage.getItem('userPlan');
            if (savedPlan) {
                try {
                    const planData = JSON.parse(savedPlan);
                    currentUserEmail = planData.email;
                    debug(`User already has a plan: ${planData.plan}`, 'info');
                    showToast(`Welcome back! You have an active ${planData.plan} plan.`, 'info');
                } catch (error) {
                    debug('Error loading saved plan: ' + error.message, 'error');
                }
            }
        }

        // Start the application when the DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
