<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Mining Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --primary: #f7931a;
            --primary-dark: #e17c0e;
            --secondary: #4d4d4d;
            --dark: #1a1a1a;
            --light: #f8f8f8;
            --danger: #d9534f;
            --success: #5cb85c;
            --warning: #f0ad4e;
            --card-bg: #2d2d2d;
            --card-border: #3d3d3d;
            --text: #e0e0e0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--card-border);
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background-color: var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            color: var(--dark);
            animation: pulse 2s infinite;
        }

        .logo-text {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }

        .network-status {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: var(--card-bg);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--success);
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .network-status {
                align-self: flex-start;
            }
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--card-border);
            margin-bottom: 20px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--card-border);
        }

        .card-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: var(--dark);
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--secondary);
            color: var(--light);
        }

        .btn-secondary:hover {
            background-color: #3a3a3a;
        }

        .btn-danger {
            background-color: var(--danger);
            color: var(--light);
        }

        .btn-danger:hover {
            background-color: #c9302c;
        }

        .btn-success {
            background-color: var(--success);
            color: var(--light);
        }

        .btn-success:hover {
            background-color: #449d44;
        }

        .btn-warning {
            background-color: var(--warning);
            color: var(--dark);
        }

        .btn-warning:hover {
            background-color: #ec971f;
        }

        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mining-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mining-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
        }

        .mining-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: var(--warning);
        }

        .mining-indicator.active {
            background-color: var(--success);
            animation: pulse 1s infinite;
        }

        .mining-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-card {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--light);
            opacity: 0.7;
        }

        .blockchain-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 600px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--card-bg);
        }

        .blockchain-section::-webkit-scrollbar {
            width: 8px;
        }

        .blockchain-section::-webkit-scrollbar-track {
            background: var(--card-bg);
        }

        .blockchain-section::-webkit-scrollbar-thumb {
            background-color: var(--primary);
            border-radius: 20px;
        }

        .block {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
            margin-bottom: 10px;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .block.new-block {
            animation: fadeIn 0.5s ease-out;
        }

        .block-header {
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .block-header:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .block-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 15px;
        }

        .block-details.active {
            max-height: 1000px;
            padding: 15px;
            border-top: 1px solid var(--card-border);
        }

        .block-details p {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--card-border);
            margin-bottom: 20px;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .tabs::-webkit-scrollbar {
            display: none;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }

        .tab.active {
            opacity: 1;
            border-bottom: 2px solid var(--primary);
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        .network-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (max-width: 480px) {
            .network-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 90%;
        }

        .toast {
            background-color: var(--card-bg);
            color: var(--light);
            padding: 15px 20px;
            border-radius: 5px;
            margin-bottom: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateX(120%);
            animation: slideInRight 0.3s forwards;
            max-width: 100%;
            word-break: break-word;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        .toast.info {
            border-left: 4px solid var(--primary);
        }

        .toast.warning {
            border-left: 4px solid var(--warning);
        }

        .toast-close {
            margin-left: auto;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .toast-close:hover {
            opacity: 1;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s infinite linear;
        }

        .difficulty-slider {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
            outline: none;
        }

        .difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--light);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .difficulty-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--light);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: none;
        }

        .difficulty-value {
            text-align: center;
            font-weight: bold;
            color: var(--primary);
            margin-top: 5px;
        }

        .blockchain-visualization {
            display: flex;
            overflow-x: auto;
            padding: 20px 0;
            gap: 10px;
            align-items: center;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--card-bg);
        }

        .blockchain-visualization::-webkit-scrollbar {
            height: 8px;
        }

        .blockchain-visualization::-webkit-scrollbar-track {
            background: var(--card-bg);
        }

        .blockchain-visualization::-webkit-scrollbar-thumb {
            background-color: var(--primary);
            border-radius: 20px;
        }

        .vis-block {
            min-width: 100px;
            height: 60px;
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .vis-block:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .vis-block::after {
            content: '';
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 2px;
            background-color: var(--primary);
        }

        .vis-block:last-child::after {
            display: none;
        }

        .vis-block-index {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
        }

        .vis-block-tx {
            font-size: 12px;
            color: var(--light);
            opacity: 0.7;
        }

        .vis-block.genesis {
            background-color: var(--primary);
            color: var(--dark);
        }

        .vis-block.genesis .vis-block-tx {
            color: var(--dark);
            opacity: 0.8;
        }

        .vis-block.mining {
            animation: pulse 1s infinite;
            border: 1px dashed var(--warning);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideInRight {
            from { transform: translateX(120%); }
            to { transform: translateX(0); }
        }

        @keyframes slideOutRight {
            from { transform: translateX(0); }
            to { transform: translateX(120%); }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .mining-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mining-animation.active {
            opacity: 1;
        }

        .mining-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--primary);
            border-radius: 50%;
            opacity: 0.7;
            animation: float 3s infinite ease-in-out;
        }

        @keyframes float {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                transform: translateY(-100px) translateX(50px);
                opacity: 0;
            }
        }

        .debug-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .debug-panel.active {
            display: block;
        }

        .debug-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--card-border);
        }

        .debug-entry:last-child {
            border-bottom: none;
        }

        .debug-time {
            color: var(--primary);
            font-weight: bold;
        }

        .debug-message {
            color: var(--light);
        }

        .debug-error {
            color: var(--danger);
        }

        .debug-success {
            color: var(--success);
        }

        .debug-warning {
            color: var(--warning);
        }

        .merkle-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        .merkle-node {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .merkle-leaf {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            text-align: center;
            min-width: 100px;
        }

        .merkle-hash {
            color: var(--primary);
            font-size: 10px;
            word-break: break-all;
        }

        .merkle-connector {
            position: relative;
            width: 100%;
            height: 20px;
        }

        .merkle-connector::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 20px;
            background-color: var(--primary);
        }

        .whitepaper-section {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--card-bg);
            border-radius: 10px;
            border: 1px solid var(--card-border);
        }

        .whitepaper-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 20px;
            text-align: center;
        }

        .whitepaper-author {
            font-style: italic;
            text-align: center;
            margin-bottom: 20px;
            color: var(--text);
        }

        .whitepaper-content {
            line-height: 1.8;
            text-align: justify;
        }

        .whitepaper-content p {
            margin-bottom: 15px;
        }

        .whitepaper-content h2 {
            color: var(--primary);
            margin: 30px 0 15px;
            font-size: 20px;
        }

        .mining-explanation {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
        }

        .mining-explanation h3 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .mining-explanation p {
            margin-bottom: 10px;
        }

        .mining-explanation code {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }

        .mining-progress {
            margin-top: 15px;
        }

        .progress-bar-container {
            width: 100%;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        .mining-limit {
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
            text-align: center;
        }

        .mining-limit-value {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
        }

        .mining-limit-label {
            font-size: 12px;
            color: var(--light);
            opacity: 0.7;
        }

        .mining-limit-progress {
            margin-top: 10px;
        }

        .mining-reward {
            margin-top: 15px;
            text-align: center;
        }

        .mining-reward-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }

        .mining-reward-label {
            font-size: 14px;
            color: var(--light);
            opacity: 0.7;
        }

        .pow-visualization {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            border: 1px solid var(--card-border);
        }

        .pow-visualization h3 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .pow-step {
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .pow-step-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .pow-step-content {
            font-family: monospace;
            word-break: break-all;
        }

        .pow-target {
            color: var(--success);
        }

        .pow-hash {
            color: var(--warning);
        }

        .pow-match {
            color: var(--success);
            font-weight: bold;
        }

        .pow-nomatch {
            color: var(--danger);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">₿</div>
                <div class="logo-text">Bitcoin Mining Simulator</div>
            </div>
            <div class="network-status">
                <div class="status-indicator"></div>
                <span id="network-status-text">Connected</span>
            </div>
        </header>

        <div class="network-stats">
            <div class="stat-card">
                <div class="stat-value" id="network-difficulty">4</div>
                <div class="stat-label">Difficulty</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="network-hashrate">0 H/s</div>
                <div class="stat-label">Network Hashrate</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="blocks-mined">0</div>
                <div class="stat-label">Blocks Mined</div>
            </div>
        </div>

        <div class="blockchain-visualization" id="blockchain-visualization">
            <!-- Visualization will be populated by JavaScript -->
        </div>

        <div class="dashboard">
            <div class="left-column">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Mining Control</div>
                    </div>
                    <div class="mining-section">
                        <div class="mining-status">
                            <div class="mining-indicator" id="mining-indicator"></div>
                            <span id="mining-status">Idle</span>
                        </div>
                        <div class="mining-stats">
                            <div class="stat-card">
                                <div class="stat-value" id="hashrate">0 H/s</div>
                                <div class="stat-label">Hashrate</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="nonce">0</div>
                                <div class="stat-label">Current Nonce</div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="difficulty-slider">Mining Difficulty</label>
                            <input type="range" class="difficulty-slider" id="difficulty-slider" min="1" max="6" value="4">
                            <div class="difficulty-value" id="difficulty-value">4</div>
                        </div>
                        <div class="mining-limit">
                            <div class="mining-limit-value" id="mining-limit-value">0.000064 BTC / 0.000064 BTC</div>
                            <div class="mining-limit-label">Daily Mining Limit (6 USD)</div>
                            <div class="mining-limit-progress">
                                <div class="progress-bar-container">
                                    <div class="progress-bar" id="mining-limit-progress-bar" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="mining-limit-label" id="mining-limit-reset">Resets in 24:00:00</div>
                        </div>
                        <div class="mining-reward">
                            <div class="mining-reward-value" id="mining-reward">0.000000 BTC</div>
                            <div class="mining-reward-label">Total Mined Today</div>
                        </div>
                        <div class="mining-actions">
                            <button class="btn btn-success" id="start-mining-btn">Start Mining</button>
                            <button class="btn btn-danger" id="stop-mining-btn" disabled>Stop Mining</button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Proof-of-Work Visualization</div>
                    </div>
                    <div class="pow-visualization" id="pow-visualization">
                        <h3>Current Mining Process</h3>
                        <div class="pow-step">
                            <div class="pow-step-title">Block Data:</div>
                            <div class="pow-step-content" id="pow-block-data">...</div>
                        </div>
                        <div class="pow-step">
                            <div class="pow-step-title">Target:</div>
                            <div class="pow-step-content">Hash must start with <span class="pow-target" id="pow-target">0000</span></div>
                        </div>
                        <div class="pow-step">
                            <div class="pow-step-title">Current Hash:</div>
                            <div class="pow-step-content"><span class="pow-hash" id="pow-current-hash">...</span></div>
                        </div>
                        <div class="pow-step">
                            <div class="pow-step-title">Result:</div>
                            <div class="pow-step-content" id="pow-result">Searching for valid hash...</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Mining Explanation</div>
                    </div>
                    <div class="mining-explanation">
                        <h3>What is Bitcoin Mining?</h3>
                        <p>Bitcoin mining is the process of adding transaction records to Bitcoin's public ledger of past transactions (the blockchain). This ledger of past transactions is called the blockchain as it is a chain of blocks.</p>
                        
                        <h3>How Proof-of-Work Functions</h3>
                        <p>The proof-of-work system requires miners to find a number called a "nonce". When this nonce is combined with the block data and hashed, it produces a hash that meets specific criteria - typically starting with a certain number of zeros.</p>
                        
                        <p>The steps are:</p>
                        <ol>
                            <li>Take the block data (previous hash, timestamp, transactions, etc.)</li>
                            <li>Add a nonce (starting from 0)</li>
                            <li>Calculate the SHA-256 hash of this combined data</li>
                            <li>Check if the hash meets the difficulty target (starts with a specific number of zeros)</li>
                            <li>If not, increment the nonce and try again</li>
                        </ol>
                        
                        <p>This process requires significant computational power, which secures the network by making it economically impractical to attack.</p>
                    </div>
                </div>
            </div>

            <div class="right-column">
                <div class="card">
                    <div class="tabs">
                        <div class="tab active" data-tab="blockchain">Blockchain</div>
                        <div class="tab" data-tab="merkle">Merkle Tree</div>
                        <div class="tab" data-tab="whitepaper">Whitepaper</div>
                    </div>

                    <div class="tab-content active" id="blockchain-tab">
                        <div class="blockchain-section" id="blockchain-container">
                            <!-- Blockchain will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="tab-content" id="merkle-tab">
                        <div class="merkle-tree" id="merkle-tree">
                            <!-- Merkle tree will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="tab-content" id="whitepaper-tab">
                        <div class="whitepaper-section">
                            <div class="whitepaper-title">Bitcoin: A Peer-to-Peer Electronic Cash System</div>
                            <div class="whitepaper-author">Satoshi Nakamoto</div>
                            <div class="whitepaper-content">
                                <p>
                                    A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network.
                                </p>
                                <p>
                                    The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power.
                                </p>
                                <h2>4. Proof-of-Work</h2>
                                <p>
                                    To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash, rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash.
                                </p>
                                <p>
                                    For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container">
        <!-- Toasts will be added by JavaScript -->
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loader"></div>
    </div>

    <!-- Mining Animation -->
    <div class="mining-animation" id="mining-animation">
        <!-- Mining particles will be added by JavaScript -->
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debug-panel">
        <!-- Debug messages will be added by JavaScript -->
    </div>

    <script>
        // Bitcoin Mining Simulator Implementation
        class MerkleTree {
            constructor(transactions) {
                this.transactions = transactions;
                this.tree = this.buildTree();
            }

            buildTree() {
                // If no transactions, return empty tree
                if (this.transactions.length === 0) {
                    return [];
                }

                // Get transaction hashes as leaves
                let leaves = this.transactions.map(tx => tx.hash);
                
                // If odd number of leaves, duplicate the last one
                if (leaves.length % 2 === 1) {
                    leaves.push(leaves[leaves.length - 1]);
                }

                // Build tree bottom-up
                let tree = [leaves];
                let level = leaves;

                while (level.length > 1) {
                    let nextLevel = [];
                    
                    for (let i = 0; i < level.length; i += 2) {
                        const left = level[i];
                        const right = level[i + 1];
                        const combined = left + right;
                        const hash = CryptoJS.SHA256(combined).toString();
                        nextLevel.push(hash);
                    }
                    
                    // If odd number of nodes, duplicate the last one
                    if (nextLevel.length % 2 === 1 && nextLevel.length > 1) {
                        nextLevel.push(nextLevel[nextLevel.length - 1]);
                    }
                    
                    tree.push(nextLevel);
                    level = nextLevel;
                }

                return tree;
            }

            getRoot() {
                if (this.tree.length === 0) return null;
                return this.tree[this.tree.length - 1][0];
            }
        }

        class Transaction {
            constructor(fromAddress, toAddress, amount, timestamp = Date.now()) {
                this.fromAddress = fromAddress;
                this.toAddress = toAddress;
                this.amount = amount;
                this.timestamp = timestamp;
                this.hash = this.calculateHash();
            }

            calculateHash() {
                return CryptoJS.SHA256(
                    this.fromAddress +
                    this.toAddress +
                    this.amount +
                    this.timestamp
                ).toString();
            }
        }

        class Block {
            constructor(timestamp, transactions, previousHash = '') {
                this.timestamp = timestamp;
                this.transactions = transactions;
                this.previousHash = previousHash;
                this.nonce = 0;
                this.merkleRoot = this.calculateMerkleRoot();
                this.hash = this.calculateHash();
            }

            calculateMerkleRoot() {
                const merkleTree = new MerkleTree(this.transactions);
                return merkleTree.getRoot() || '0';
            }

            calculateHash() {
                return CryptoJS.SHA256(
                    this.previousHash +
                    this.timestamp +
                    this.merkleRoot +
                    this.nonce
                ).toString();
            }

            mineBlock(difficulty) {
                const target = Array(difficulty + 1).join('0');
                
                while (this.hash.substring(0, difficulty) !== target) {
                    this.nonce++;
                    this.hash = this.calculateHash();
                    
                    // Yield to UI thread occasionally
                    if (this.nonce % 100 === 0) {
                        return false; // Not done yet
                    }
                }
                
                return true; // Block mined
            }

            getMerkleTree() {
                return new MerkleTree(this.transactions);
            }
        }

        class Blockchain {
            constructor() {
                this.chain = [this.createGenesisBlock()];
                this.difficulty = 4;
                this.miningReward = 0.000064; // 6 USD worth of BTC
                this.blockTime = 10000; // Target time between blocks in ms
                this.lastBlockTime = Date.now();
                
                debug('Blockchain initialized with genesis block', 'success');
            }

            createGenesisBlock() {
                return new Block(Date.now(), [], '0');
            }

            getLatestBlock() {
                return this.chain[this.chain.length - 1];
            }

            minePendingTransactions(minerAddress) {
                try {
                    // Create coinbase transaction (mining reward)
                    const rewardTx = new Transaction('Coinbase', minerAddress, this.miningReward);
                    
                    // Create new block
                    const block = new Block(Date.now(), [rewardTx], this.getLatestBlock().hash);
                    
                    // Mine block
                    const mined = block.mineBlock(this.difficulty);
                    
                    if (mined) {
                        // Add block to chain
                        this.chain.push(block);
                        
                        // Adjust difficulty based on block time
                        this.adjustDifficulty();
                        
                        debug(`Block mined successfully: ${block.hash.substring(0, 10)}...`, 'success');
                        return true;
                    }
                    
                    return false;
                } catch (error) {
                    debug('Error mining block: ' + error.message, 'error');
                    return false;
                }
            }

            adjustDifficulty() {
                const currentTime = Date.now();
                const timeElapsed = currentTime - this.lastBlockTime;
                
                if (timeElapsed < this.blockTime / 2) {
                    // Blocks are being mined too quickly, increase difficulty
                    this.difficulty = Math.min(this.difficulty + 1, 6);
                    debug(`Difficulty increased to ${this.difficulty}`, 'info');
                } else if (timeElapsed > this.blockTime * 2) {
                    // Blocks are being mined too slowly, decrease difficulty
                    this.difficulty = Math.max(this.difficulty - 1, 1);
                    debug(`Difficulty decreased to ${this.difficulty}`, 'info');
                }
                
                this.lastBlockTime = currentTime;
            }

            isChainValid() {
                for (let i = 1; i < this.chain.length; i++) {
                    const currentBlock = this.chain[i];
                    const previousBlock = this.chain[i - 1];
                    
                    try {
                        // Validate hash
                        if (currentBlock.hash !== currentBlock.calculateHash()) {
                            debug(`Invalid block hash at height ${i}`, 'error');
                            return false;
                        }
                        
                        // Validate previous hash reference
                        if (currentBlock.previousHash !== previousBlock.hash) {
                            debug(`Invalid previous hash reference at height ${i}`, 'error');
                            return false;
                        }
                        
                        // Validate merkle root
                        if (currentBlock.merkleRoot !== currentBlock.calculateMerkleRoot()) {
                            debug(`Invalid merkle root at height ${i}`, 'error');
                            return false;
                        }
                    } catch (error) {
                        debug('Chain validation error: ' + error.message, 'error');
                        return false;
                    }
                }
                
                debug('Blockchain validated successfully', 'success');
                return true;
            }
        }

        class Miner {
            constructor(blockchain) {
                this.blockchain = blockchain;
                this.mining = false;
                this.hashrate = 0;
                this.startTime = 0;
                this.hashCount = 0;
                this.blocksMined = 0;
                this.totalMined = 0;
                this.dailyLimit = 0.000064; // 6 USD worth of BTC
                this.dailyMined = 0;
                this.lastResetTime = Date.now();
                this.resetInterval = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                this.minerAddress = 'MinerAddress';
                this.currentNonce = 0;
                this.currentHash = '';
            }

            startMining() {
                if (this.dailyMined >= this.dailyLimit) {
                    showToast('Daily mining limit reached. Try again tomorrow.', 'warning');
                    return false;
                }

                this.mining = true;
                this.startTime = Date.now();
                this.hashCount = 0;
                
                // Start mining animation
                startMiningAnimation();
                
                this.mineNextBlock();
                
                debug('Mining started', 'info');
                return true;
            }

            stopMining() {
                this.mining = false;
                
                // Stop mining animation
                stopMiningAnimation();
                
                debug('Mining stopped', 'info');
            }

            mineNextBlock() {
                if (!this.mining) return;
                
                try {
                    // Check if daily limit reached
                    if (this.dailyMined >= this.dailyLimit) {
                        showToast('Daily mining limit reached. Try again tomorrow.', 'warning');
                        this.stopMining();
                        return;
                    }

                    // Create a new block to mine
                    const latestBlock = this.blockchain.getLatestBlock();
                    const rewardTx = new Transaction('Coinbase', this.minerAddress, this.blockchain.miningReward);
                    const block = new Block(Date.now(), [rewardTx], latestBlock.hash);
                    
                    // Try to find a valid hash
                    const target = Array(this.blockchain.difficulty + 1).join('0');
                    
                    // Update UI with current mining attempt
                    this.currentNonce = block.nonce;
                    this.currentHash = block.hash;
                    document.getElementById('nonce').textContent = this.currentNonce;
                    document.getElementById('pow-block-data').textContent = `PrevHash: ${block.previousHash.substring(0, 10)}..., Timestamp: ${block.timestamp}, MerkleRoot: ${block.merkleRoot.substring(0, 10)}...`;
                    document.getElementById('pow-target').textContent = target;
                    document.getElementById('pow-current-hash').textContent = this.currentHash;
                    
                    if (this.currentHash.substring(0, this.blockchain.difficulty) === target) {
                        document.getElementById('pow-result').innerHTML = `<span class="pow-match">MATCH FOUND!</span>`;
                    } else {
                        document.getElementById('pow-result').innerHTML = `<span class="pow-nomatch">No match yet, continuing...</span>`;
                    }
                    
                    // Increment nonce and calculate new hash
                    block.nonce++;
                    block.hash = block.calculateHash();
                    
                    // Increment hash count
                    this.hashCount += 1;
                    
                    // Check if we found a valid hash
                    if (block.hash.substring(0, this.blockchain.difficulty) === target) {
                        // Block successfully mined
                        this.blocksMined++;
                        this.dailyMined += this.blockchain.miningReward;
                        this.totalMined += this.blockchain.miningReward;
                        
                        // Add block to blockchain
                        this.blockchain.chain.push(block);
                        
                        showToast(`Block mined successfully! Earned ${this.blockchain.miningReward.toFixed(8)} BTC`, 'success');
                        updateBlockchainDisplay();
                        updateMerkleTreeDisplay();
                        updateMiningLimitDisplay();
                        
                        // Play mining success animation
                        playMiningSuccessAnimation();
                        
                        // Calculate hashrate
                        const endTime = Date.now();
                        const timeElapsed = (endTime - this.startTime) / 1000; // in seconds
                        this.hashrate = Math.round(this.hashCount / timeElapsed);
                        
                        // Reset for next block
                        this.startTime = Date.now();
                        this.hashCount = 0;
                    }
                    
                    // Update hashrate every second
                    const currentTime = Date.now();
                    if (currentTime - this.startTime > 1000) {
                        const timeElapsed = (currentTime - this.startTime) / 1000;
                        this.hashrate = Math.round(this.hashCount / timeElapsed);
                        document.getElementById('hashrate').textContent = formatHashrate(this.hashrate);
                    }
                    
                    // Continue mining
                    if (this.mining) {
                        setTimeout(() => this.mineNextBlock(), 0);
                    }
                } catch (error) {
                    debug('Mining error: ' + error.message, 'error');
                    showToast('Mining error: ' + error.message, 'error');
                    this.stopMining();
                }
            }

            checkDailyReset() {
                const currentTime = Date.now();
                if (currentTime - this.lastResetTime >= this.resetInterval) {
                    this.dailyMined = 0;
                    this.lastResetTime = currentTime;
                    updateMiningLimitDisplay();
                    debug('Daily mining limit reset', 'info');
                }
            }

            getTimeUntilReset() {
                const currentTime = Date.now();
                const timeElapsed = currentTime - this.lastResetTime;
                const timeRemaining = this.resetInterval - timeElapsed;
                
                if (timeRemaining <= 0) {
                    this.checkDailyReset();
                    return '00:00:00';
                }
                
                // Convert to hours, minutes, seconds
                const hours = Math.floor(timeRemaining / (60 * 60 * 1000));
                const minutes = Math.floor((timeRemaining % (60 * 60 * 1000)) / (60 * 1000));
                const seconds = Math.floor((timeRemaining % (60 * 1000)) / 1000);
                
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            getHashrate() {
                return this.hashrate;
            }

            getBlocksMined() {
                return this.blocksMined;
            }

            getDailyMined() {
                return this.dailyMined;
            }

            getDailyLimit() {
                return this.dailyLimit;
            }

            getTotalMined() {
                return this.totalMined;
            }
        }

        // Debug function
        function debug(message, type = 'info') {
            const debugPanel = document.getElementById('debug-panel');
            const debugEntry = document.createElement('div');
            debugEntry.className = 'debug-entry';
            
            const time = new Date().toLocaleTimeString();
            debugEntry.innerHTML = `
                <span class="debug-time">[${time}]</span>
                <span class="debug-${type}">${message}</span>
            `;
            
            debugPanel.appendChild(debugEntry);
            
            // Auto-scroll to bottom
            debugPanel.scrollTop = debugPanel.scrollHeight;
            
            // Limit entries
            while (debugPanel.children.length > 50) {
                debugPanel.removeChild(debugPanel.firstChild);
            }
            
            // Log to console as well
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Initialize blockchain
        const bitcoin = new Blockchain();
        const miner = new Miner(bitcoin);

        // DOM elements
        const startMiningButton = document.getElementById('start-mining-btn');
        const stopMiningButton = document.getElementById('stop-mining-btn');
        const miningStatusElement = document.getElementById('mining-status');
        const miningIndicatorElement = document.getElementById('mining-indicator');
        const difficultySlider = document.getElementById('difficulty-slider');
        const difficultyValueElement = document.getElementById('difficulty-value');
        const networkDifficultyElement = document.getElementById('network-difficulty');
        const hashrateElement = document.getElementById('hashrate');
        const networkHashrateElement = document.getElementById('network-hashrate');
        const blocksMined = document.getElementById('blocks-mined');
        const loadingOverlay = document.getElementById('loading-overlay');
        const miningAnimation = document.getElementById('mining-animation');
        const debugPanel = document.getElementById('debug-panel');
        const miningLimitValue = document.getElementById('mining-limit-value');
        const miningLimitProgressBar = document.getElementById('mining-limit-progress-bar');
        const miningLimitReset = document.getElementById('mining-limit-reset');
        const miningReward = document.getElementById('mining-reward');
        const nonceElement = document.getElementById('nonce');

        // Event listeners
        startMiningButton.addEventListener('click', startMining);
        stopMiningButton.addEventListener('click', stopMining);
        difficultySlider.addEventListener('input', updateDifficulty);

        // Debug panel toggle (press D key)
        document.addEventListener('keydown', function(event) {
            if (event.key === 'd' || event.key === 'D') {
                debugPanel.classList.toggle('active');
            }
        });

        // Tab switching
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                
                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                const tabContents = document.querySelectorAll('.tab-content');
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                // Update Merkle tree if that tab is selected
                if (tabId === 'merkle') {
                    updateMerkleTreeDisplay();
                }
            });
        });

        // Start mining
        function startMining() {
            const started = miner.startMining();
            
            if (started) {
                // Update UI
                startMiningButton.disabled = true;
                stopMiningButton.disabled = false;
                miningStatusElement.textContent = 'Mining';
                miningIndicatorElement.classList.add('active');
                
                showToast('Mining started', 'info');
                
                // Start hashrate update interval
                startHashrateInterval();
                
                // Start mining limit reset timer
                startMiningLimitTimer();
            }
        }

        // Stop mining
        function stopMining() {
            miner.stopMining();

            // Update UI
            startMiningButton.disabled = false;
            stopMiningButton.disabled = true;
            miningStatusElement.textContent = 'Idle';
            miningIndicatorElement.classList.remove('active');
            
            showToast('Mining stopped', 'info');
            
            // Stop hashrate update interval
            clearInterval(hashrateInterval);
            
            // Stop mining limit reset timer
            clearInterval(miningLimitTimer);
        }

        // Update difficulty
        function updateDifficulty() {
            const difficulty = parseInt(difficultySlider.value);
            difficultyValueElement.textContent = difficulty;
            bitcoin.difficulty = difficulty;
            networkDifficultyElement.textContent = difficulty;
            document.getElementById('pow-target').textContent = Array(difficulty + 1).join('0');
        }

        // Update blockchain display
        function updateBlockchainDisplay() {
            const blockchainContainer = document.getElementById('blockchain-container');
            const blockchainVisualization = document.getElementById('blockchain-visualization');
            
            // Clear containers
            blockchainContainer.innerHTML = '';
            blockchainVisualization.innerHTML = '';
            
            // Update blockchain visualization
            bitcoin.chain.forEach((block, index) => {
                const blockElement = document.createElement('div');
                blockElement.className = index === 0 ? 'vis-block genesis' : 'vis-block';
                
                blockElement.innerHTML = `
                    <div class="vis-block-index">${index}</div>
                    <div class="vis-block-tx">${block.transactions.length} tx</div>
                `;
                
                blockElement.addEventListener('click', () => {
                    // Find and open the detailed block in the blockchain container
                    const detailedBlock = document.querySelector(`.block[data-index="${index}"] .block-details`);
                    if (detailedBlock) {
                        detailedBlock.classList.add('active');
                        
                        // Switch to blockchain tab
                        document.querySelector('.tab[data-tab="blockchain"]').click();
                        
                        // Scroll to the block
                        detailedBlock.scrollIntoView({ behavior: 'smooth' });
                    }
                });
                
                blockchainVisualization.appendChild(blockElement);
            });
            
            // Add mining block visualization if mining
            if (miner.mining) {
                const miningBlockElement = document.createElement('div');
                miningBlockElement.className = 'vis-block mining';
                
                miningBlockElement.innerHTML = `
                    <div class="vis-block-index">?</div>
                    <div class="vis-block-tx">Mining...</div>
                `;
                
                blockchainVisualization.appendChild(miningBlockElement);
            }
            
            // Update detailed blockchain view
            bitcoin.chain.forEach((block, index) => {
                const blockElement = document.createElement('div');
                blockElement.className = 'block';
                blockElement.setAttribute('data-index', index);
                
                if (index === bitcoin.chain.length - 1) {
                    blockElement.classList.add('new-block');
                }
                
                const blockHeader = document.createElement('div');
                blockHeader.className = 'block-header';
                blockHeader.innerHTML = `
                    <span>Block #${index}</span>
                    <span>${block.hash.substring(0, 10)}...</span>
                `;
                
                blockHeader.addEventListener('click', () => {
                    blockDetails.classList.toggle('active');
                });
                
                const blockDetails = document.createElement('div');
                blockDetails.className = 'block-details';
                blockDetails.innerHTML = `
                    <p><strong>Timestamp:</strong> ${new Date(block.timestamp).toLocaleString()}</p>
                    <p><strong>Hash:</strong> ${block.hash}</p>
                    <p><strong>Previous Hash:</strong> ${block.previousHash}</p>
                    <p><strong>Merkle Root:</strong> ${block.merkleRoot}</p>
                    <p><strong>Nonce:</strong> ${block.nonce}</p>
                    <p><strong>Difficulty:</strong> ${bitcoin.difficulty}</p>
                    <p><strong>Transactions:</strong> ${block.transactions.length}</p>
                `;
                
                if (block.transactions.length > 0) {
                    const transactionsContainer = document.createElement('div');
                    transactionsContainer.className = 'transactions-container';
                    
                    block.transactions.forEach(tx => {
                        const txElement = document.createElement('div');
                        txElement.className = 'transaction';
                        
                        if (index === bitcoin.chain.length - 1) {
                            txElement.classList.add('new-tx');
                        }
                        
                        txElement.innerHTML = `
                            <p><strong>From:</strong> ${tx.fromAddress}</p>
                            <p><strong>To:</strong> ${tx.toAddress}</p>
                            <p><strong>Amount:</strong> ${tx.amount} BTC</p>
                            <p><strong>Hash:</strong> ${tx.hash.substring(0, 15)}...</p>
                        `;
                        
                        transactionsContainer.appendChild(txElement);
                    });
                    
                    blockDetails.appendChild(transactionsContainer);
                }
                
                blockElement.appendChild(blockHeader);
                blockElement.appendChild(blockDetails);
                blockchainContainer.appendChild(blockElement);
            });
            
            // Update blocks mined
            blocksMined.textContent = miner.getBlocksMined();
        }

        // Update Merkle tree display
        function updateMerkleTreeDisplay() {
            const merkleTreeContainer = document.getElementById('merkle-tree');
            merkleTreeContainer.innerHTML = '';
            
            // Get the latest block with transactions
            let latestBlockWithTx = null;
            for (let i = bitcoin.chain.length - 1; i >= 0; i--) {
                if (bitcoin.chain[i].transactions.length > 0) {
                    latestBlockWithTx = bitcoin.chain[i];
                    break;
                }
            }
            
            if (!latestBlockWithTx) {
                merkleTreeContainer.innerHTML = '<p>No blocks with transactions yet</p>';
                return;
            }
            
            // Create Merkle tree
            const merkleTree = latestBlockWithTx.getMerkleTree();
            const tree = merkleTree.tree;
            
            if (tree.length === 0) {
                merkleTreeContainer.innerHTML = '<p>No transactions to build Merkle tree</p>';
                return;
            }
            
            // Create visual representation of the tree
            for (let i = 0; i < tree.length; i++) {
                const level = tree[i];
                const levelDiv = document.createElement('div');
                levelDiv.className = 'merkle-node';
                
                level.forEach(hash => {
                    const leafDiv = document.createElement('div');
                    leafDiv.className = 'merkle-leaf';
                    
                    // For the bottom level (transactions), show tx info
                    if (i === 0) {
                        // Find the transaction for this hash
                        const tx = latestBlockWithTx.transactions.find(tx => tx.hash === hash);
                        if (tx) {
                            leafDiv.innerHTML = `
                                <div>Tx: ${tx.fromAddress} → ${tx.toAddress}</div>
                                <div class="merkle-hash">${hash.substring(0, 10)}...</div>
                            `;
                        } else {
                            leafDiv.innerHTML = `<div class="merkle-hash">${hash.substring(0, 10)}...</div>`;
                        }
                    } else {
                        leafDiv.innerHTML = `<div class="merkle-hash">${hash.substring(0, 10)}...</div>`;
                    }
                    
                    levelDiv.appendChild(leafDiv);
                });
                
                merkleTreeContainer.appendChild(levelDiv);
                
                // Add connectors between levels
                if (i < tree.length - 1) {
                    const connectorDiv = document.createElement('div');
                    connectorDiv.className = 'merkle-connector';
                    merkleTreeContainer.appendChild(connectorDiv);
                }
            }
        }

        // Update mining limit display
        function updateMiningLimitDisplay() {
            const dailyMined = miner.getDailyMined();
            const dailyLimit = miner.getDailyLimit();
            const percentage = (dailyMined / dailyLimit) * 100;
            
            miningLimitValue.textContent = `${dailyMined.toFixed(8)} BTC / ${dailyLimit.toFixed(8)} BTC`;
            miningLimitProgressBar.style.width = `${percentage}%`;
            miningReward.textContent = `${dailyMined.toFixed(8)} BTC`;
            
            // Check if limit reached
            if (dailyMined >= dailyLimit) {
                showToast('Daily mining limit reached. Try again tomorrow.', 'warning');
                if (miner.mining) {
                    stopMining();
                }
            }
        }

        // Show loading overlay
        function showLoading() {
            loadingOverlay.classList.add('active');
        }

        // Hide loading overlay
        function hideLoading() {
            loadingOverlay.classList.remove('active');
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            toast.innerHTML = `
                <div>${message}</div>
                <div class="toast-close">&times;</div>
            `;
            
            const closeButton = toast.querySelector('.toast-close');
            closeButton.addEventListener('click', () => {
                toast.style.animation = 'slideOutRight 0.3s forwards';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            });
            
            toastContainer.appendChild(toast);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideOutRight 0.3s forwards';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.remove();
                        }
                    }, 300);
                }
            }, 5000);
        }

        // Format hashrate
        function formatHashrate(hashrate) {
            if (hashrate < 1000) {
                return `${hashrate} H/s`;
            } else if (hashrate < 1000000) {
                return `${(hashrate / 1000).toFixed(2)} KH/s`;
            } else {
                return `${(hashrate / 1000000).toFixed(2)} MH/s`;
            }
        }

        // Start mining animation
        function startMiningAnimation() {
            miningAnimation.classList.add('active');
            
            // Create mining particles
            for (let i = 0; i < 20; i++) {
                createMiningParticle();
            }
            
            // Create particles periodically
            miningParticleInterval = setInterval(() => {
                createMiningParticle();
            }, 300);
        }

        // Create mining particle
        function createMiningParticle() {
            const particle = document.createElement('div');
            particle.className = 'mining-particle';
            
            // Random position
            const x = Math.random() * window.innerWidth;
            const y = window.innerHeight;
            
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            
            // Random animation duration
            const duration = 2 + Math.random() * 3;
            particle.style.animation = `float ${duration}s infinite ease-in-out`;
            
            miningAnimation.appendChild(particle);
            
            // Remove after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.remove();
                }
            }, duration * 1000);
        }

        // Stop mining animation
        function stopMiningAnimation() {
            miningAnimation.classList.remove('active');
            clearInterval(miningParticleInterval);
            
            // Remove all particles
            while (miningAnimation.firstChild) {
                miningAnimation.removeChild(miningAnimation.firstChild);
            }
        }

        // Play mining success animation
        function playMiningSuccessAnimation() {
            // Flash the screen
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'rgba(247, 147, 26, 0.3)';
            flash.style.zIndex = '998';
            flash.style.pointerEvents = 'none';
            
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.remove();
            }, 500);
        }

        // Hashrate update interval
        let hashrateInterval;
        let miningParticleInterval;
        let miningLimitTimer;
        
        function startHashrateInterval() {
            hashrateInterval = setInterval(() => {
                const hashrate = miner.getHashrate();
                hashrateElement.textContent = formatHashrate(hashrate);
                networkHashrateElement.textContent = formatHashrate(hashrate);
                nonceElement.textContent = miner.currentNonce;
            }, 1000);
        }

        function startMiningLimitTimer() {
            miningLimitTimer = setInterval(() => {
                miner.checkDailyReset();
                miningLimitReset.textContent = `Resets in ${miner.getTimeUntilReset()}`;
            }, 1000);
        }

        // Initialize the application
        function init() {
            // Update UI
            updateBlockchainDisplay();
            updateMiningLimitDisplay();
            
            // Set initial difficulty
            difficultySlider.value = bitcoin.difficulty;
            difficultyValueElement.textContent = bitcoin.difficulty;
            networkDifficultyElement.textContent = bitcoin.difficulty;
            
            // Mine a genesis block with a reward
            const genesisBlock = new Block(Date.now(), [new Transaction('Coinbase', 'Genesis', 50)], '0');
            genesisBlock.mineBlock(bitcoin.difficulty);
            bitcoin.chain[0] = genesisBlock;
            
            // Update UI
            updateBlockchainDisplay();
            updateMerkleTreeDisplay();
            
            // Start mining limit timer
            startMiningLimitTimer();
            
            debug('Bitcoin mining simulator initialized and ready', 'success');
            
            // Show debug panel by default to help users
            debugPanel.classList.add('active');
            
            // Show welcome toast
            showToast('Welcome to Bitcoin Mining Simulator! Click "Start Mining" to begin.', 'info');
        }

        // Start the application when the DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
